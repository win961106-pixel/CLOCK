#define FASTLED_INTERNAL 

#include <WiFi.h>
#include <PubSubClient.h>
#include <NeoPixelBus.h> 
#include <FastLED.h>     
#include <arduinoFFT.h>  
#include <SinricPro.h>   
#include <SinricProSwitch.h>
#include <IRremoteESP8266.h>
#include <IRsend.h>
#include <NTPClient.h>
#include <WiFiUdp.h>

// ================== Á∂≤Ë∑ØËàáÈáëÈë∞Ë®≠ÂÆö ==================
#define WIFI_SSID        "16-3AP"
#define WIFI_PASSWORD    "0935131327"
#define MQTT_SERVER      "broker.emqx.io"
#define MQTT_PORT        1883

#define APP_KEY          "3840c2b8-98e5-4c11-b3dd-d0300357b38e"
#define APP_SECRET       "3795425b-1f2f-41ac-a5ee-1dd586e9704f"
#define DEVICE_ID_TV     "694fcd90729a4887d7eb6d8d"
#define DEVICE_ID_SP     "694fce3c00f870dd77d668e0"
#define DEVICE_ID_PC     "694fcde100f870dd77d66876"

// ================== PIN Ë®≠ÂÆö ==================
#define PIN_TV             18
#define PIN_SPEAKER        4
#define PIN_LED            17    
#define PIN_MIC            34
#define PIN_LDR            35
#define PIN_POT            32
#define PIN_BUTTON_MAIN    13
#define PIN_TRIGGER_AUDIO  4
#define PIN_BUTTON_AUDIO   14
#define PIN_RELAY_PC       15
#define PIN_IR_SEND        25
#define PIN_IR_RECV        26

// ================== Áü©Èô£ËàáÈ°ØÁ§∫Ë®≠ÂÆö ==================
#define LED_COUNT          420
#define MATRIX_ROWS        12
#define MATRIX_COLS        35

CRGB leds[LED_COUNT];
NeoPixelBus<NeoGrbFeature, NeoEsp32I2s1800KbpsMethod> strip(LED_COUNT, PIN_LED);

#define BRIGHTNESS_MIN     10
#define BRIGHTNESS_MAX     80

enum DisplayMode { MODE_CLOCK, MODE_AUDIO, MODE_TRANSITION };
DisplayMode currentMode = MODE_CLOCK;
DisplayMode nextMode = MODE_CLOCK;

// ================== ÂÖ®ÂüüËÆäÊï∏ ==================
uint8_t clockR = 255, clockG = 255, clockB = 255;
float sensLow = 1.0, sensMid = 1.0, sensHigh = 1.0, globalSens = 1.5;
int audioStyle = 0;    
int currentBrightness = 30;

// ================== FFT Ë®≠ÂÆö ==================
#define FFT_SAMPLES 128
#define FFT_SAMPLING_FREQ 10000
double vReal[FFT_SAMPLES];
double vImag[FFT_SAMPLES];
arduinoFFT FFT = arduinoFFT(vReal, vImag, FFT_SAMPLES, FFT_SAMPLING_FREQ);
int bands[MATRIX_COLS];
int peaks[MATRIX_COLS]; 

// ================== Áâ©‰ª∂ÂàùÂßãÂåñ ==================
WiFiClient espClient;
PubSubClient mqttClient(espClient);
IRsend irsend(PIN_IR_SEND);
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 28800, 60000);

// ================== ÊôÇÈñìËàáÈò≤ÂΩàË∑≥ËÆäÊï∏ ==================
uint16_t dissolveOrder[LED_COUNT];
int dissolveIndex = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastPeakDrop = 0;

// ÂñáÂè≠Ëß∏ÁôºËÆäÊï∏
int actualTriggerState = HIGH;  
int lastFlickerState = HIGH;    
unsigned long lastDebounceTime = 0; 

// ÊåâÈàïËß∏ÁôºËÆäÊï∏
bool lastBtnMain = HIGH;
bool lastBtnAudio = HIGH;
unsigned long lastBtnTime = 0;

unsigned long lastMqttRetry = 0;

// ================== Â≠óÂûãË≥áÊñô ==================
const uint16_t digits[10][12] = {
  {0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100},
  {0b0001000, 0b0011000, 0b0101000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0001000, 0b0111110},
  {0b0011100, 0b0100010, 0b1000001, 0b0000001, 0b0000010, 0b0000100, 0b0001000, 0b0010000, 0b0100000, 0b1000000, 0b1000010, 0b1111100},
  {0b0011100, 0b0100010, 0b1000001, 0b0000001, 0b0000010, 0b0001100, 0b0000010, 0b0000001, 0b0000001, 0b1000001, 0b0100010, 0b0011100},
  {0b0000100, 0b0001100, 0b0010100, 0b0100100, 0b1000100, 0b1000100, 0b1111110, 0b0000100, 0b0000100, 0b0000100, 0b0000100, 0b0001110},
  {0b0111110, 0b1000000, 0b1000000, 0b1000000, 0b1111100, 0b0000010, 0b0000001, 0b0000001, 0b0000001, 0b1000001, 0b0100010, 0b0011100},
  {0b0011100, 0b0100010, 0b1000000, 0b1000000, 0b1000000, 0b1111100, 0b1000010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100},
  {0b1111110, 0b0000010, 0b0000100, 0b0000100, 0b0001000, 0b0001000, 0b0010000, 0b0010000, 0b0100000, 0b0100000, 0b0100000, 0b0100000},
  {0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b0100010, 0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100010, 0b0011100},
  {0b0011100, 0b0100010, 0b1000001, 0b1000001, 0b1000001, 0b0100011, 0b0011110, 0b0000001, 0b0000001, 0b1000001, 0b0100010, 0b0011100}
};
const uint8_t smallDigits[10][5] = {
  {0b111, 0b101, 0b101, 0b101, 0b111}, {0b010, 0b110, 0b010, 0b010, 0b111},
  {0b111, 0b001, 0b111, 0b100, 0b111}, {0b111, 0b001, 0b111, 0b001, 0b111},
  {0b101, 0b101, 0b111, 0b001, 0b001}, {0b111, 0b100, 0b111, 0b001, 0b111},
  {0b111, 0b100, 0b111, 0b101, 0b111}, {0b111, 0b001, 0b010, 0b100, 0b100},
  {0b111, 0b101, 0b111, 0b101, 0b111}, {0b111, 0b101, 0b111, 0b001, 0b111}
};

// ================== ËºîÂä©ÂáΩÂºè ==================
uint16_t XY(uint8_t x, uint8_t y) {
  bool flipX = false;  
  bool flipY = true;  

  if (flipX) x = (MATRIX_COLS - 1) - x;
  if (flipY) y = (MATRIX_ROWS - 1) - y;

  uint16_t i;
  if (y & 0x01) {
    uint8_t reverseX = (MATRIX_COLS - 1) - x;
    i = (y * MATRIX_COLS) + reverseX;
  } else {
    i = (y * MATRIX_COLS) + x;
  }
  return (i < LED_COUNT) ? i : 0;
}

void updateLEDs() {
  for (uint16_t i = 0; i < LED_COUNT; i++) {
    uint8_t r = scale8(leds[i].r, currentBrightness);
    uint8_t g = scale8(leds[i].g, currentBrightness);
    uint8_t b = scale8(leds[i].b, currentBrightness);
    strip.SetPixelColor(i, RgbColor(r, g, b));
  }
  strip.Show(); 
}

void initDissolveArray() {
  for (uint16_t i = 0; i < LED_COUNT; i++) dissolveOrder[i] = i;
  for (uint16_t i = LED_COUNT - 1; i > 0; i--) {
    uint16_t j = random(i + 1);
    uint16_t temp = dissolveOrder[i];
    dissolveOrder[i] = dissolveOrder[j];
    dissolveOrder[j] = temp;
  }
}

void triggerTransition(DisplayMode targetMode) {
  if (currentMode != targetMode && currentMode != MODE_TRANSITION) {
    nextMode = targetMode;
    currentMode = MODE_TRANSITION;
    dissolveIndex = 0;
    initDissolveArray();
  }
}

void drawPixelSafe(int x, int y, CRGB color) {
  if (x >= 0 && x < MATRIX_COLS && y >= 0 && y < MATRIX_ROWS) {
    leds[XY(x, y)] = color;
  }
}

void drawLargeDigit(int startX, int startY, int digit, CRGB color) {
  for (int y = 0; y < 12; y++) {
    for (int x = 0; x < 7; x++) {
      if (digits[digit][y] & (1 << (6 - x))) {
        drawPixelSafe(startX + x, startY + y, color);
      }
    }
  }
}

void drawSmallDigit(int startX, int startY, int digit, CRGB color) {
  for (int y = 0; y < 5; y++) {
    for (int x = 0; x < 3; x++) {
      if (smallDigits[digit][y] & (1 << (2 - x))) { 
        drawPixelSafe(startX + x, startY + y, color); 
      }
    }
  }
}

void renderLargeClock(CRGB color) {
  int h = timeClient.getHours();
  int m = timeClient.getMinutes();
  int h1 = h / 10, h2 = h % 10;
  int m1 = m / 10, m2 = m % 10;
  
  int x = 0; int y = 0;
  drawLargeDigit(x, y, h1, color); x += 8;
  drawLargeDigit(x, y, h2, color); x += 8;
  
  if ((millis() / 500) % 2 == 0) {
    drawPixelSafe(x, 3, color); drawPixelSafe(x+1, 3, color);
    drawPixelSafe(x, 4, color); drawPixelSafe(x+1, 4, color);
    drawPixelSafe(x, 7, color); drawPixelSafe(x+1, 7, color);
    drawPixelSafe(x, 8, color); drawPixelSafe(x+1, 8, color);
  }
  x += 3;
  drawLargeDigit(x, y, m1, color); x += 8;
  drawLargeDigit(x, y, m2, color);
}

void overlaySmallClock(int hours, int minutes, CRGB color) {
  int h1 = hours / 10, h2 = hours % 10;
  int m1 = minutes / 10, m2 = minutes % 10;
  int x = 17, y = 0;  

  if (h1 > 0) drawSmallDigit(x, y, h1, color); 
  x += 4; drawSmallDigit(x, y, h2, color); x += 4;
  
  if ((millis() / 500) % 2 == 0) { 
    drawPixelSafe(x, y + 1, color); drawPixelSafe(x, y + 3, color);
  }
  x += 2; 
  drawSmallDigit(x, y, m1, color); x += 4;
  drawSmallDigit(x, y, m2, color);
}

void processAudio() {
  unsigned long sampling_period_us = round(1000000 * (1.0 / FFT_SAMPLING_FREQ));
  for (int i = 0; i < FFT_SAMPLES; i++) {
    unsigned long newTime = micros();
    int rawValue = analogRead(PIN_MIC) - 1700; 
    vReal[i] = rawValue;
    vImag[i] = 0;
    while ((micros() - newTime) < sampling_period_us) { }
  }

  FFT.Windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  FFT.Compute(FFT_FORWARD);
  FFT.ComplexToMagnitude();

  for (int i = 0; i < MATRIX_COLS; i++) {
    int binNum = map(i, 0, MATRIX_COLS - 1, 2, 40); 
    float amplitude = vReal[binNum];

    if (i < 10) amplitude *= sensLow;
    else if (i < 25) amplitude *= sensMid;
    else amplitude *= sensHigh;
    
    int ledHeight = map(amplitude * globalSens, 0, 1000, 0, MATRIX_ROWS);
    if (ledHeight <= 1) ledHeight = 0; 
    
    if (ledHeight < 0) ledHeight = 0;
    if (ledHeight > MATRIX_ROWS) ledHeight = MATRIX_ROWS;
    bands[i] = ledHeight;

    if (bands[i] >= peaks[i]) peaks[i] = bands[i];
  }
}

void renderAudioVisualizer(int style) {
  memset(leds, 0, sizeof(leds)); 
  processAudio();
  uint8_t baseHue = millis() / 30; 

  if (millis() - lastPeakDrop > 80) {
    for (int i = 0; i < MATRIX_COLS; i++) {
      if (peaks[i] > 0) peaks[i]--;
    }
    lastPeakDrop = millis();
  }

  for (int x = 0; x < MATRIX_COLS; x++) {
    int h = bands[x];
    switch (style) {
      case 0:
        for (int y = 0; y < h; y++) drawPixelSafe(x, MATRIX_ROWS - 1 - y, CHSV(baseHue + x * 5 + y * 10, 255, 255));
        break;
      case 1:
        for (int y = 0; y < h; y++) drawPixelSafe(x, MATRIX_ROWS - 1 - y, CHSV(baseHue + x * 5 + y * 10, 255, 200));
        if (peaks[x] > 0 && peaks[x] < MATRIX_ROWS) drawPixelSafe(x, MATRIX_ROWS - 1 - peaks[x], CRGB::White);
        break;
      case 2:
        for (int y = 0; y < h / 2; y++) {
          CRGB col = CHSV(baseHue + x * 5 + y * 15, 255, 255);
          drawPixelSafe(x, 5 - y, col); drawPixelSafe(x, 6 + y, col); 
        }
        break;
      case 3:
        for (int y = 0; y < h; y++) {
          int brightness = map(y, 0, h, 255, 50);
          drawPixelSafe(x, MATRIX_ROWS - 1 - y, CHSV(baseHue + x * 8, 200, brightness));
        }
        fadeToBlackBy(leds, LED_COUNT, 40); 
        break;
    }
  }
}

// ================== Sinric Pro ÂõûÂëº ==================
bool onPowerStatePC(const String &deviceId, bool &state) {
  if (state) {
    digitalWrite(PIN_RELAY_PC, HIGH);
    delay(500); 
    digitalWrite(PIN_RELAY_PC, LOW);
  }
  return true; 
}

bool onPowerStateTV(const String &deviceId, bool &state) {
  irsend.sendNEC(0x20DF10EF, 32); 
  if (state) mqttClient.publish("esp32/status/tv", "ON");
  else mqttClient.publish("esp32/status/tv", "OFF");
  return true;
}

bool onPowerStateSpeaker(const String &deviceId, bool &state) {
  irsend.sendSony(0xA90, 12);     
  if (state) mqttClient.publish("esp32/status/speaker", "ON");
  else mqttClient.publish("esp32/status/speaker", "OFF");
  return true;
}

// ================== MQTT ÂõûÂëºËàáÈÄ£Á∑ö ==================
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String message = "";
  for (int i = 0; i < length; i++) message += (char)payload[i];
  String t = String(topic);
  
  if (t == "esp32/color/r") clockR = message.toInt();
  if (t == "esp32/color/g") clockG = message.toInt();
  if (t == "esp32/color/b") clockB = message.toInt();
  if (t == "esp32/sens/low") sensLow = message.toFloat();
  if (t == "esp32/sens/mid") sensMid = message.toFloat();
  if (t == "esp32/sens/high") sensHigh = message.toFloat();
  
  if (t == "esp32/audio/style") {
    audioStyle = message.toInt();
    triggerTransition(MODE_AUDIO);
  }
  
  if (t == "esp32/control/pc" && message == "ON") {
     digitalWrite(PIN_RELAY_PC, HIGH);
     delay(500);
     digitalWrite(PIN_RELAY_PC, LOW);
  }
  if (t == "esp32/control/ir") {
     if (message == "tv_power") irsend.sendNEC(0x20DF10EF, 32); 
     if (message == "sp_power") irsend.sendSony(0xA90, 12);     
  }
}

void reconnectMQTT() {
  if (!mqttClient.connected() && (millis() - lastMqttRetry > 5000)) {
    Serial.print("ÂòóË©¶ÈÄ£Á∑ö MQTT...");
    String clientId = "CyberClock_ESP32_" + String(random(0xffff), HEX);
    if (mqttClient.connect(clientId.c_str())) {
      Serial.println("ÈÄ£Á∑öÊàêÂäüÔºÅ");
      mqttClient.subscribe("esp32/color/#");
      mqttClient.subscribe("esp32/sens/#");
      mqttClient.subscribe("esp32/audio/style");
      mqttClient.subscribe("esp32/control/#");
    }
    lastMqttRetry = millis();
  }
}

// ================== Setup ==================
void setup() {
  Serial.begin(115200);
  
  pinMode(PIN_RELAY_PC, OUTPUT);
  digitalWrite(PIN_RELAY_PC, LOW);
  
  pinMode(PIN_TRIGGER_AUDIO, INPUT_PULLDOWN);
  pinMode(PIN_BUTTON_MAIN, INPUT_PULLDOWN);
  pinMode(PIN_BUTTON_AUDIO, INPUT_PULLDOWN);
  
  pinMode(PIN_POT, INPUT);
  pinMode(PIN_LDR, INPUT);
  
  strip.Begin();
  strip.Show();

  irsend.begin();

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) delay(500);
  timeClient.begin();
  
  mqttClient.setServer(MQTT_SERVER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);

  SinricProSwitch& myPC = SinricPro[DEVICE_ID_PC];
  myPC.onPowerState(onPowerStatePC);
  SinricProSwitch& myTV = SinricPro[DEVICE_ID_TV];
  myTV.onPowerState(onPowerStateTV);
  SinricProSwitch& mySpeaker = SinricPro[DEVICE_ID_SP];
  mySpeaker.onPowerState(onPowerStateSpeaker);
  SinricPro.begin(APP_KEY, APP_SECRET);
}

// ================== ‰∏ªËø¥Âúà ==================
void loop() {
  SinricPro.handle();
  if (!mqttClient.connected()) reconnectMQTT();
  mqttClient.loop(); 
  timeClient.update();

  int potValue = analogRead(PIN_POT);
  currentBrightness = map(potValue, 0, 4095, BRIGHTNESS_MIN, BRIGHTNESS_MAX);

  // ==========================================
  // üöÄ 1. ÂØ¶È´îÊåâÈàïËÆÄÂèñ (bÊé•Èªû: Êåâ‰∏ãÊñ∑ÈñãÂæû HIGH ËÆä LOW)
  // ==========================================
  bool btnMain = digitalRead(PIN_BUTTON_MAIN);
  bool btnAudio = digitalRead(PIN_BUTTON_AUDIO);

  if (millis() - lastBtnTime > 50) { // 50ms ÊåâÈàïÈò≤ÂΩàË∑≥
    
    // ‰∏ªÊåâÈàïÔºöÊåâ‰∏ãËß∏ÁôºÈõªËÖ¶ÈñãÊ©ü
    if (btnMain == LOW && lastBtnMain == HIGH) {
      digitalWrite(PIN_RELAY_PC, HIGH);
      delay(500);
      digitalWrite(PIN_RELAY_PC, LOW);
      lastBtnTime = millis();
    }

    // ÂâØÊåâÈàïÔºöÊåâ‰∏ãÂàáÊèõÈü≥È†ªÊ®£Âºè (0->1->2->3->0 Âæ™Áí∞)
    if (btnAudio == LOW && lastBtnAudio == HIGH) {
      audioStyle = (audioStyle + 1) % 4;
      triggerTransition(MODE_AUDIO);
      // ÂêåÊ≠•ÊääÁãÄÊÖãÂõûÂÇ≥Áµ¶Á∂≤È†Å
      mqttClient.publish("esp32/audio/style", String(audioStyle).c_str());
      lastBtnTime = millis();
    }
  }
  lastBtnMain = btnMain;
  lastBtnAudio = btnAudio;

  // ==========================================
  // üöÄ 2. ÂñáÂè≠Ëá™ÂãïÂàáÊèõÈÇèËºØ (Â∑≤‰øÆÊ≠£ÈÇèËºØÈ°õÂÄíÂïèÈ°å)
  // ==========================================
  int reading = digitalRead(PIN_TRIGGER_AUDIO);
  if (reading != lastFlickerState) {
    lastDebounceTime = millis(); 
  }
  if ((millis() - lastDebounceTime) > 300) {
    if (reading != actualTriggerState) {
      actualTriggerState = reading; 
      
      // üöÄ ÈÇèËºØÂèçËΩâ‰øÆÊ≠£ÔºöHIGH ÊôÇÈÄ≤Èü≥È†ªÊ®°ÂºèÔºåLOW ÊôÇÂõûÊôÇÈêòÊ®°Âºè
      if (actualTriggerState == HIGH) {
        triggerTransition(MODE_AUDIO); 
      } else {
        triggerTransition(MODE_CLOCK); 
      }
    }
  }
  lastFlickerState = reading; 

  // ==========================================
  // üöÄ 3. Áï´Èù¢Êõ¥Êñ∞
  // ==========================================
  if (millis() - lastDisplayUpdate > 30) {
    CRGB mainColor = CRGB(clockR, clockG, clockB);

    switch (currentMode) {
      case MODE_CLOCK:
        memset(leds, 0, sizeof(leds));
        renderLargeClock(mainColor);
        updateLEDs();
        break;

      case MODE_AUDIO:
        renderAudioVisualizer(audioStyle);
        overlaySmallClock(timeClient.getHours(), timeClient.getMinutes(), mainColor);
        updateLEDs();
        break;

      case MODE_TRANSITION:
        for (int i = 0; i < 15; i++) {
          if (dissolveIndex < LED_COUNT) {
            leds[dissolveOrder[dissolveIndex]] = CRGB::Black;
            dissolveIndex++;
          }
        }
        updateLEDs();
        if (dissolveIndex >= LED_COUNT) {
          memset(leds, 0, sizeof(leds));
          currentMode = nextMode;
        }
        break;
    }
    lastDisplayUpdate = millis();
  }
}
